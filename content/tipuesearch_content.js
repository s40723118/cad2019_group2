var tipuesearch = {"pages": [{'title': 'About', 'text': '此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n', 'tags': '', 'url': 'About.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. \n', 'tags': '', 'url': 'Develop.html'}, {'title': 'Solvespace', 'text': '', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Tutorial practice', 'text': 'tutorial 1 simple plate \n \n tutorial 2 three-way connector \n \n tutorial_3_ Sketch Rotation around an Axis \n \n tutorial_4_Assembly \n \n tutorial_6_Christmas Tree(BONUS) \n \n tutorial_7_Constrained Movement \n \n tutorial_8_Interactive 3D Model in Browser \n \xa0 \xa0tutorial 11: Cubic Bezier Spline tool (Vase) \n \n \n \n tutorial_9_a Simple Gear \n \n tutorial_10_ Fidget Spinner \n \n tutorial_11_cubic bezier spline tool (vase) \n \n tutorial_12_How to create a Mechanical Linked System \n \n 繪圖驗證1 \n \n 繪圖驗證3 \n \n 繪圖驗證4 \n \n 繪圖認證6 \n \n 繪圖認證7 \n \n 繪圖認證8 \n \n 繪圖認證9 \n \n 繪圖認證10 \n \n 繪圖認證11 \n \n 繪圖認證12 \n \n 繪圖認證13 \n \n 繪圖認證14 \n \n 繪圖認證15 \n \n 繪圖認證16 \n \n 繪圖認證17 \n \n 繪圖驗證18 \n \n \n', 'tags': '', 'url': 'Tutorial practice.html'}, {'title': 'Car model', 'text': '\n 檔案位子:carmodel/carbody.slvs \n 參考圖像: https://www.google.com/search?q=rainbow+six++Unmanned+vehicle&rlz=1C1GCEA_enTW812TW812&sxsrf=ACYBGNRHnkoLe0kouEp3qp6hRlMV8B3EQQ:1571582838834&source=lnms&tbm=isch&sa=X&ved=0ahUKEwjo1d-miqvlAhUryIsBHRXQCT0Q_AUIEigB&biw=871&bih=843#imgrc=_ \n <<<<<<< HEAD \n >>>>>>> bce730699bbf79fca6977ab6b67993bb4e3ee75c \n', 'tags': '', 'url': 'Car model.html'}, {'title': 'Solidworks', 'text': '', 'tags': '', 'url': 'Solidworks.html'}, {'title': '開發起源', 'text': '起初Jon Hirschtick 和 Axel Bichara在創業班中組成一個團隊，他們寫了一個商業企劃，內容是叫做 Premise的 新CAD軟體公司。 \n Premise最初的軟體產品是Design View，是一個二維的繪圖軟體。雖然軟體的開發很成功但是由於市場太小以至於無法蓬勃發展起來，後來就被Computervision公司給收購了。 \n Jon Hirschtick\xa0和 Axel Bichara也到了Computervision的管理團隊待了一陣子，不過後來Axel Bichara待了大約一年就離開回到法國攻讀MBA學位。 \n 1993年8月Jon Hirschtick也離開了Computervision，因為他不知道他下一步該做什麼也覺得他除了經營公司以外應該還有其他的事情可以做。 \n 1994年1月一個創造低成本桌面設計系統基於實體模型技術的想法開始出現，於是Jon Hirschtick組成了一個團隊，成員包括 Bob Zuffante, Scott Harris, Constantine Dokos和Tommy Li，最終發展出 的產品就為Solidworks。 \n', 'tags': '', 'url': '開發起源.html'}, {'title': 'Solidworks 繪圖練習', 'text': '\n', 'tags': '', 'url': 'Solidworks 繪圖練習.html'}, {'title': 'Inventor', 'text': '', 'tags': '', 'url': 'Inventor.html'}, {'title': 'Practice', 'text': '>>>>>>> e57712a9a4b0cd2222e8ab8be05fcaf682d69cd9 \n \n', 'tags': '', 'url': 'Practice.html'}, {'title': 'NX12', 'text': '', 'tags': '', 'url': 'NX12.html'}, {'title': 'NX12繪圖練習', 'text': '\n', 'tags': '', 'url': 'NX12繪圖練習.html'}, {'title': '教材整理', 'text': '', 'tags': '', 'url': '教材整理.html'}, {'title': 'Ch1~2', 'text': '第1章主要介紹CAD/CAM/CAE的定義及本課本其他章的簡介 第2.1章如何打開nx12的文件 第一步打開nx12 第二步如何打開新的文件\u3000使用頂部按鈕打開新的文件 或 選用菜單打開 或 使用"ctrl+n" 然後跳出介面 確認尺寸為毫米 可以改名稱及位置 第三步如何打開新的零件文件\u3000使用頂部按鈕打開新的零件文件 或 選用菜單打開 或 使用"ctrl+ｏ" 第2.2章如何打印，保存和關閉零件文件 打印 File →Print 選擇要使用的打印機或指定編號 打印份數，紙張尺寸等。可以為所有三個選擇比例尺寸。可以選擇通過單擊來打印，即線框實體模型輸出下拉菜單 保存 File →Save  關閉零件文件 File →Close 第2.3章如何使用滑鼠及nx12的介面介紹 第2.4章圖層 第2.5章座標系統 第2.6章工具欄 \n 實際操作影片 \n \n \n', 'tags': '', 'url': 'Ch1~2.html'}, {'title': 'Ch5~6', 'text': '\n 5-1 如何選擇平面與如何視圖 5-2 設定紙張尺寸大小、第幾角法 \n 切換視角與關閉不必要的線條 \n 5-3 尺寸標註 \n 5-4 切換剖視圖 \n 5-5 在實體面標註尺寸 \n \n 5-6 \n 草圖繪製,給予形狀公差 \n \n 6-1 \n 分辨零件、組合件 \n 6-2 \n 使用Top-Down Approach(由上而下的畫法),Bottom-Up Approach(由下而上的畫法) \n 6-3 \n 了解零件如何互相約束 \n 6-4 \n 使用不同的約束 \n 分別為: 對齊;同心;距離;平行;垂直;鍵合;置中;角度 \n \n 6-5,6-6 \n 操作實際例題 \n', 'tags': '', 'url': 'Ch5~6.html'}, {'title': 'Ch7', 'text': 'Ch7\xa0 自由曲面的建模 \n 此章節主要在講述可以利用何種方法來建構曲面 \n 1.利用"點"來建立曲面 \n (1)利用四個點來建立一曲面 \n (2)以矩形點陣列構成的多個點來建立一曲面 \n (3)定義的點形成矩形陣列與穿過它們的線相切 \n ---------------------------------------------------------------------------------- \n 2.利用"線"來建立曲面 \n (1)用兩條大致平行的線 \n (2)3條或以上大致平行的線 \n (3)由至少4條剖面線，且存在至少2條線段方向關係為垂直且平行於面區域 \n (4)由至少2條剖面線且有2條大致垂直的線和2條剖面線有重和關係 \n ---------------------------------------------------------------------------------- \n 3.利用面來建立自由曲面 \n (1)利用原有的曲面來偏移 \n (2)利用原有曲面的面或邊來做延伸的功能 \n', 'tags': '', 'url': 'Ch7.html'}, {'title': 'Ch8', 'text': '第8章－有限元分析 \n Finite Element Analysis (FEA)有限元分析 - 預測結構或流體對應用因素（例如力，壓力，熱量和振動等等 ...) 而本章我們我們重點在於處理實體零件的結構應力和應變分析也就是應力和位移 . \n 8.1.1.\xa0 element(元素/元件)的形狀和節點 \n 元素可分為尺寸 (dimensions) 數和節點 (nodes) 數兩大因素，而這兩大因素則用於分離化(discretization) \n \n', 'tags': '', 'url': 'Ch8.html'}, {'title': 'Ch9', 'text': '第 9 章 \n 此章節在介紹如何使用 NX12 生成用於三軸立式加工中心的 CNC 代碼製造模組，該模組使我們可以對鑽孔，銑削，車削和線切割 EDM 刀具路徑進行編程和一些後續處理。 \n 9-1 入門 \n 創建新檔案 → 設定加工環境 → 操作導航器 ( 註 1)→ 設定機器座標系統 (MCS) → 定義幾何 \n 9-2 創建操作 \n 建立新操作 → 建立新工具並選擇 → 設定工具路徑 → 跨距和 Scallop 高度 ( 註 2)→ 設定每次切削深度 → 設定切削深度 → 設定迴避點 → 調整速度與進給 \n 9-3 生成程序和驗證 \n 生成程序 → 顯示刀具路徑 → 模擬刀具路徑 → 鑿檢驗 ( 註 3) \n 9-4 操作方法 \n 粗加工→半精加工 → 整理零件內外輪廓→精加工外部輪廓 → 精加工內部輪廓 \n 9-5 後期處理 \n 創建 CLSF→ 後期處理 \n \xa0 \n 註 1  “操作導航器”提供有關所創建程序的信息以及有關刀具，方法和策略的相應信息，可以在不同的類別列表中查看程序列表。 \n \xa0 \n 註 2  跨距的大小和刀具直徑將決定每步之間的 Scallop 高度。 減小跨步距離將使 Scallop 高度減低，但需要更多的步幅，因此需要更多的時間來加工特徵。 \n \xa0 \n 註 3  鑿檢驗用於驗證刀具是否確實從工件上去除了多餘的材料。在製造過程有缺陷的零件有兩種可能。一種是去除多餘的材料，另一種是留下應該清除的材料。在大多數情況下，前者更不理想，因為其不可能重新設計。 \n', 'tags': '', 'url': 'Ch9.html'}, {'title': 'Webots', 'text': '<<<<<<< Updated upstream ======= \n >>>>>>> 964fdc740c8f66990d245210f0d18d30016f4138 \n >>>>>>> Stashed changes \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'tutorial', 'text': 'tutorial_1_my_first_simulation \n \n', 'tags': '', 'url': 'tutorial.html'}, {'title': 'W17 協同任務', 'text': 'Building a clean model tutorial \n 40723144、40523241:Building the visible shapes \n 40723153:Building the joints \n 40723138:Building the dynamic shapes \n 40723118、40723132:Model definition \n 40723145:Webots modification of the environment \n 各組員在完成翻譯後自行建立一個h2的標題(以自己學號命名)將自己所做的部分打在裡面 \n <<<<<<< HEAD \n', 'tags': '', 'url': 'W17 協同任務.html'}, {'title': '40723145', 'text': '\n', 'tags': '', 'url': '40723145.html'}, {'title': '40723118', 'text': "In our case, only option 2 is of interest. 在我們的情況下，只有選項2是有意義的。 \n We create a force/torque sensor with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object robot_link_dyn6. 我們使用[菜單欄->添加->力傳感器]創建一個力/扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象robot_link_dyn6。 \n We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available).We also change its name to robot_attachment: 我們會適當地更改其尺寸和外觀（紅色力/扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為robot_attachment： \n \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the \xa0 Assembling/disassembling toolbar button .  The gripper goes into place: 現在，我們將抓手模型拖到場景中，使其保持選中狀態，然後按住Control鍵單擊並單擊附著力傳感器，然後單擊“裝配/拆卸”工具欄按鈕。 夾持器到位： \n \n The gripper knew how to attach itself because it was appropriately configured during its model definition. 抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。 \n We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. 現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。 \n We select the robot model, then click Assembling in the \xa0 object common properties . Set an empty string for 'Parent' match values, then click Set matrix.  我們選擇機器人模型，然後在對象公共屬性中單擊“組裝”。為“Parent”匹配值設置一個空字符串，然後單擊“設置矩陣”。 \n This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model Models/robots/mobile/KUKA Omnirob.ttm into the scene. 這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位/定向。為了驗證我們做的正確，我們將模型Models / robots / mobile / KUKA Omnirob.ttm拖到場景中。 \n Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the  Assembling/disassembling toolbar button . Our robot should correctly place itself on top of the mobile robot: 然後，我們選擇機器人模型，然後在移動平台上按住Control鍵並單擊其中一個附接點，然後單擊“組裝/拆卸”工具欄按鈕。我們的機器人應該正確地將自己放置在移動機器人的頂部： \n \n Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach \xa0 embedded scripts  to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand  how object handles are accessed from embedded scripts . 現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將嵌入式腳本附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。 在這種情況下，請確保了解如何從嵌入式腳本訪問對象句柄。 \n We can also control/access/interface our model from a  plugin , from a \xa0 remote API  client, from a  ROS  node, from a \xa0 BlueZero  node, or from an  add-on . 我們還可以通過插件，遠程API客戶端，ROS節點，BlueZero節點或附加組件來控制/訪問/接口模型。 \n Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the model folder, then the model will be available in the \xa0 model brower . 現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用[菜單欄->文件->將模型另存為 ...]。 如果我們將其保存在模型文件夾中，則模型將在模型瀏覽器中可用。 \n ======= \n", 'tags': '', 'url': '40723118.html'}, {'title': '40723138', 'text': '\n Building the dynamic shapes 建立動態形狀 \n 為了模擬真實機器人遇到情況 我們須先設定環境(建立地形) 地形可以為 1.dynamic or static:動態（或非靜態）形狀會掉落並受到外力/扭矩的影響。另一方面，靜態（或非動態）形狀將保持不變，或跟隨其父級在場景層次中的移動。 (類似一般的地形) 2.respondable or non-respondable：可響應形狀會引起與其他可響應形狀的碰撞反應。如果它們是動態的，它們（和/或它們的對撞機）的運動將受到影響 。另一方面，不負責任的形狀如果與其他形狀發生碰撞，則不會計算碰撞響應。 (類似有機關的) \n 上述兩大類又可合併成5大類 pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes \n Pure shapes 將穩定並由物理引擎非常有效地處理。 缺點是純形狀的幾何形狀受到限制：主要是長方體，圓柱體和球體。 如果可能的話，將它們用於與其他物品接觸時間較長的物品 （例如，人形機器人的腳，串行操縱器的底座，抓手的手指等） \n Pure compound shapes: 是幾個純形狀的組合。它的性能幾乎與純形狀一樣，並具有相似的特性。 可以通過對幾個純形狀進行分組來生成純複合形狀 \n Convex shapes: 與純形狀相比，它允許使用更通用的幾何形狀（僅要求：它必須是凸形的）。 如果可能，將凸形用於偶爾與其他物品接觸的物品（例如，機器人的各個鏈接）。 \n Compound convex shapes, or convex decomposed shapes: 它的性能幾乎與凸形相同，並具有相似的特性。 \n Random shapes：隨機形狀是既非凸形也不是純淨的形狀。它通常具有較差的性能 \n \n 由此得知建構順序為pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes \n 由於我們希望動態形狀僅對物理引擎可見，而對其他計算模塊不可見 因此在object common properties取消選中動態形狀的所有object special properties for the dynamic shapes \n 然後，我們仍然必須將動態形狀配置為dynamic和responseable在shape dynamics properties使用, 檢查主要的本體是否為respondable item,而其他不需要被引響的物件取消Local respondable mask flags 以便不必要的干擾 \n 大多數情況下，我們需要機器人的基礎（即robot_dyn）為非動態（即靜態），否則，如果單獨使用，則機器人可能會在運動過程中掉落。 但是，一旦我們將機器人的底座連接到移動平台上，我們就希望底座變得動態（即非靜態）。 除了機器人的基座之外，所有動態形狀都應下降。附加的視覺形狀將跟隨其動態吊墜。 點擊Compute mass & inertia properties for selected convex shapes基底以外的機構使他符合shape dynamics properties. \n \n >>>>>>> adfcbad43f707e908355f499f505b23af6ae5a8a \n \n', 'tags': '', 'url': '40723138.html'}]};